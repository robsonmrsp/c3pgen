package ${application.corePackage}.persistence;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import javax.inject.Inject;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Order;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;

import org.apache.log4j.Logger;
import org.hibernate.Criteria;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.criterion.Restrictions;
import org.hibernate.query.NativeQuery;
import ${application.corePackage}.persistence.pagination.PaginationParams;

<#if application.multitenancy>
import ${application.corePackage}.model.Owner;
</#if>
/* generated by JSetup ${JSetupVersion} :  at ${.now} */
@SuppressWarnings("unchecked")
public class HibernateDao<Entity> {

	@Inject
	SessionFactory sessionFactory;

	private static final Logger LOGGER = Logger.getLogger(HibernateDao.class);

	private Class<Entity> clazz;
	private CriteriaBuilder builder;
	private CriteriaQuery<Entity> query;
	private Root<Entity> root;
	private CriteriaQuery<Long> queryCount;
	private Root<Entity> rootCount;

	protected CriteriaQuery<Long> queryCount() {
		if (queryCount == null) {
			queryCount = builder().createQuery(Long.class);
		}
		return queryCount;
	}

	protected CriteriaQuery<Entity> query() {
		if (query == null) {
			query = builder().createQuery(this.clazz);
		}
		return query;
	}

	protected Root<Entity> root() {
		if (root == null) {
			root = query().from(this.clazz);
		}
		return root;
	}

	protected Root<Entity> rootCount() {
		if (rootCount == null) {
			rootCount = queryCount().from(this.clazz);
		}
		return rootCount;
	}

	protected CriteriaBuilder builder() {
		if (builder == null) {
			builder = getCriteriaBuilder();
		}
		return builder;
	}

	public HibernateDao(Class<Entity> clazz) {
		this.clazz = clazz;
	}


	public CriteriaBuilder getCriteriaBuilder() {
		return getSession().getCriteriaBuilder();
	}

	public Session getSession() {
		return sessionFactory.getCurrentSession();
	}

	public Entity find(Serializable key) {
		if (key == null) {
			return null;
		}
		return (Entity) sessionFactory.getCurrentSession().get(clazz, key);
	}
	<#if application.multitenancy>

	public List<Entity> getAll(Owner owner) {

		CriteriaBuilder builder = getCriteriaBuilder();
		CriteriaQuery<Entity> query = builder.createQuery(this.clazz);
		Root<Entity> root = query.from(this.clazz);

		Predicate and = builder.and(builder.equal(root.get("owner").get("id"), owner.getId()));

		TypedQuery<Entity> typedQuery = getSession().createQuery(query.select(root).where(and));

		List<Entity> entities = typedQuery.setMaxResults(200).getResultList();

		return entities;
	}

	public Entity find(Serializable key, Owner owner) {
		
		CriteriaBuilder builder = getCriteriaBuilder();
		CriteriaQuery<Entity> query = builder.createQuery(this.clazz);
		Root<Entity> root = query.from(this.clazz);

		Predicate and = builder.and(builder.equal(root.get("owner").get("id"), owner.getId()));

		TypedQuery<Entity> typedQuery = getSession().createQuery(query.select(root).where(and));

		return typedQuery.getSingleResult(); 
	}
	</#if>

	public List<Entity> getAll() {
		LOGGER.warn("Aparentemente voce est√° tentando fazer uma consulta FULL SCAN. Por efeitos de performance, estamos limitando essa consulta aos primeiros 100 registos.");
		List<Entity> entities = sessionFactory.getCurrentSession().createCriteria(clazz).setMaxResults(100).list();
		return entities;
	}

	public Entity save(Entity entity) {
		Session currentSession = sessionFactory.getCurrentSession();
		currentSession.merge(entity);
		return entity;
	}

	public Boolean delete(Serializable entityId) {
		Entity entity = find(entityId);
		if (entity != null) {
			sessionFactory.getCurrentSession().delete(entity);
			sessionFactory.getCurrentSession().flush();
		}
		return Boolean.TRUE;
	}

	public CriteriaQuery<Entity> criteriaQuery() {

		CriteriaBuilder builder = sessionFactory.getCriteriaBuilder();
		CriteriaQuery<Entity> query = builder.createQuery(this.clazz);

		return query;
	}

	public NativeQuery<Entity> nativeQuery(String nativeSql) {
		return getSession().createNativeQuery(nativeSql);
	}

	public Order getOrderBy(PaginationParams queryParams) {
		String queryOrderBy = queryParams.getOrderBy();
		Order orderBy = null;//
		if (!queryOrderBy.isEmpty()) {
			String[] ord = null;
			String order = queryParams.getOrder();
			if (queryOrderBy.contains(".")) {
				ord = queryOrderBy.split("\\.");
				if (order.equalsIgnoreCase("DESC")) {
					orderBy = builder.desc(root.get(ord[0]).get(ord[1]));
				} else {
					orderBy = builder.asc(root.get(ord[0]).get(ord[1]));
				}
			} else {
				if (order.equalsIgnoreCase("DESC")) {
					orderBy = builder.desc(root.get(queryOrderBy));
				} else {
					orderBy = builder.asc(root.get(queryOrderBy));
				}
			}
		} else {
			orderBy = builder.desc(root.get("id"));
		}
		return orderBy;
	}

}
